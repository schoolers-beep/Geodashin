<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Geometry Dash JS - Ultimate</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Pusab&family=Roboto:wght@900&display=swap');

        :root {
            --primary: #00ff00;
            --secondary: #00ffff;
            --bg-top: #0066ff;
            --bg-bot: #002244;
            --glass: rgba(0, 0, 0, 0.6);
            --gold: #ffd700;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Roboto', sans-serif; /* Fallback for Pusab */
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        /* SCREENS */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; }
        
        /* BACKGROUNDS FOR MENUS */
        .menu-bg {
            background: linear-gradient(to bottom, #2980b9, #2c3e50);
            /* Animated generic GD background pattern */
            background-image: 
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        /* TEXT STYLES */
        .gd-font {
            font-family: 'Roboto', sans-serif; 
            font-weight: 900;
            text-transform: uppercase;
            text-shadow: 3px 3px 0 #000;
            font-style: italic;
        }
        
        h1 { font-size: 3rem; color: var(--gold); margin: 10px; text-shadow: 4px 4px 0px #000; }
        h2 { font-size: 2rem; color: #fff; margin: 10px; }
        
        /* BUTTONS */
        .gd-btn {
            width: 80px; height: 80px;
            margin: 10px;
            border: 3px solid white;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.1s, filter 0.1s;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 6px 0 rgba(0,0,0,0.5);
            background: linear-gradient(to bottom, #444, #222);
            position: relative;
        }
        .gd-btn:active { transform: scale(0.95) translateY(4px); box-shadow: 0 2px 0 rgba(0,0,0,0.5); }
        .gd-btn:hover { filter: brightness(1.2); }
        .gd-btn img, .gd-btn span { width: 60%; height: 60%; object-fit: contain; pointer-events: none; font-size: 2rem; color: white; text-align:center;}

        .btn-play-big {
            width: 150px; height: 150px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><polygon points="30,20 80,50 30,80" fill="%2300ff00" stroke="white" stroke-width="5"/></svg>'), linear-gradient(#444, #111);
            background-size: 60%, 100%;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* LEVEL SELECTOR */
        .level-card {
            width: 60%;
            height: 200px;
            background: rgba(0,0,0,0.6);
            border: 4px solid #fff;
            border-radius: 20px;
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            position: relative;
            backdrop-filter: blur(5px);
        }
        .level-nav-btn {
            background: rgba(0,0,0,0.5); color: white; border: 2px solid white;
            width: 50px; height: 100px; font-size: 2rem; cursor: pointer;
        }

        /* SHOP / GARAGE */
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 20px;
            border: 2px solid var(--gold);
        }
        .shop-item {
            width: 60px; height: 60px;
            border: 2px solid #555;
            background: #222;
            cursor: pointer;
            position: relative;
        }
        .shop-item.locked { opacity: 0.5; filter: grayscale(1); }
        .shop-item.selected { border-color: #00ff00; box-shadow: 0 0 15px #00ff00; }
        .currency-display {
            position: absolute; top: 20px; right: 20px;
            color: var(--secondary); font-size: 1.5rem;
            display: flex; align-items: center; gap: 10px;
        }

        /* HUD */
        .progress-container {
            position: absolute; top: 10px; left: 10%; width: 80%; height: 15px;
            background: rgba(0,0,0,0.5); border: 2px solid white; border-radius: 8px;
        }
        .progress-fill { height: 100%; width: 0%; background: #00ff00; transition: width 0.1s; }
        .percentage { position: absolute; top: 30px; width: 100%; text-align: center; color: white; font-size: 1.5rem; text-shadow: 2px 2px 0 #000; }
        
        .pause-btn {
            position: absolute; top: 10px; right: 10px;
            width: 50px; height: 50px;
            background: rgba(0,0,0,0.5); border: 2px solid white;
            color: white; font-size: 1.5rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center; pointer-events: auto;
        }

    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="ui-layer">
    <div id="game-hud" class="hidden">
        <div class="progress-container"><div class="progress-fill" id="prog-bar"></div></div>
        <div class="percentage gd-font" id="prog-text">0%</div>
        <div class="pause-btn" id="btn-pause">||</div>
    </div>
</div>

<div id="screen-menu" class="screen menu-bg">
    <h1>GEOMETRY JS</h1>
    <div class="gd-btn btn-play-big" id="btn-to-levels"></div>
    <div style="display: flex; margin-top: 20px;">
        <div class="gd-btn" id="btn-garage" style="background: linear-gradient(#909, #404);">
            <span>üëï</span>
        </div>
        <div class="gd-btn" onclick="alert('Full version coming soon!')" style="background: linear-gradient(#009, #004);">
            <span>‚òÖ</span>
        </div>
    </div>
</div>

<div id="screen-levels" class="screen menu-bg hidden">
    <div style="display:flex; align-items:center; width: 100%; justify-content: center;">
        <button class="level-nav-btn" id="lvl-prev">‚ùÆ</button>
        <div class="level-card" id="level-card-ui">
            <h2 class="gd-font" id="lvl-name">STEREO MADNESS</h2>
            <div style="display:flex; gap:10px; margin-top:10px;">
                <span id="lvl-diff">Easy</span> | <span id="lvl-stars">1 ‚òÖ</span>
            </div>
            <div style="margin-top:20px; font-size:1.2rem; color: #aaa;" id="lvl-progress">Best: 0%</div>
        </div>
        <button class="level-nav-btn" id="lvl-next">‚ùØ</button>
    </div>
    <div class="gd-btn" id="btn-back-menu" style="position: absolute; bottom: 20px; left: 20px; background: #c0392b;"><span>‚Ü©</span></div>
    <div class="gd-btn" id="btn-start-level" style="width: 120px; background: #27ae60;"><span>PLAY</span></div>
</div>

<div id="screen-garage" class="screen menu-bg hidden">
    <h1 class="gd-font">GARAGE</h1>
    <div class="currency-display gd-font">
        <div style="width:20px; height:20px; background:#00ffff; border-radius:50%; box-shadow: 0 0 5px #00ffff;"></div>
        <span id="orb-display">0</span>
    </div>
    
    <div style="color:white; margin-bottom:5px;">ICONS</div>
    <div class="shop-grid" id="icon-grid"></div>
    
    <div style="color:white; margin:15px 0 5px 0;">COLORS</div>
    <div class="shop-grid" id="color-grid"></div>

    <div class="gd-btn" id="btn-back-garage" style="position: absolute; bottom: 20px; left: 20px; background: #c0392b;"><span>‚Ü©</span></div>
</div>

<div id="screen-death" class="screen hidden" style="background: rgba(0,0,0,0.8);">
    <h1 class="gd-font" id="death-msg" style="color:white;">CRASHED</h1>
    <div class="progress-container" style="position:relative; width: 60%; left:0; top:0; margin-bottom: 20px;">
        <div class="progress-fill" id="death-prog"></div>
    </div>
    <div style="display:flex;">
        <div class="gd-btn" id="btn-retry" style="background: #27ae60;"><span>‚Üª</span></div>
        <div class="gd-btn" id="btn-quit" style="background: #c0392b;"><span>‚â°</span></div>
    </div>
</div>

<script>
/**
 * GEOMETRY DASH JS - EXACT PHYSICS ENGINE
 * * Physics derived from community research (GD Forum/Wiki).
 * 1 Block = 30 units in GD. Here we scale 1 Block = 64 pixels.
 * Speed = 10.4 blocks/sec (~665 px/sec).
 * Jump Duration ~0.55s.
 * Gravity is calculated to create a perfect parabolic arc over ~2 blocks.
 */

const CONFIG = {
    TILE_SIZE: 64,
    // Physics Constants - Tuned for authentic GD feel
    SPEED: 665.6,       // 10.4 * 64 (10.4 blocks/sec)
    GRAVITY: 4800,      // Adjusted for proper jump arc
    JUMP_FORCE: 1380,   // Tuned for ~0.55s jump duration
    TERMINAL: 2500,     // Max fall speed
    ROTATION_SPEED: 11.4, // Radians per second for 360¬∞ per jump
    
    // Ship Physics
    SHIP_GRAVITY: 3200,
    SHIP_UP_FORCE: 1800,
    SHIP_TERMINAL_UP: 1200,
    SHIP_TERMINAL_DOWN: 1500,
    
    // Hitboxes (Forgiveness factor: Hitbox is smaller than visual)
    HITBOX_SCALE: 0.7,  // Slightly more forgiving
    
    // Mechanics
    BUFFER_TIME: 0.15,  // seconds to register click before landing
    COYOTE_TIME: 0.08   // seconds to allow jump after falling off block
};

/* --- DATA: LEVELS & SHOP --- */
const LEVELS = [
    {
        id: 0,
        name: "STEREO MADNESS",
        difficulty: "Easy",
        stars: 1,
        length: 280, // in blocks
        color: "#2980b9",
        data: [ // x, y (0 is ground), type: s=spike, b=block, o=orb, p=pad, sp=ship_portal, cp=cube_portal, e=end
            // Opening sequence
            {x:10,y:0,t:'s'},{x:11,y:0,t:'s'}, 
            
            // First jump section
            {x:18,y:0,t:'b'},{x:19,y:1,t:'b'},{x:20,y:2,t:'b'}, 
            {x:25,y:0,t:'s'},{x:26,y:0,t:'s'},
            {x:32,y:0,t:'b'},{x:32,y:1,t:'s'},
            
            // Pad jump
            {x:38,y:0,t:'p'}, 
            {x:46,y:4,t:'b'},{x:47,y:4,t:'b'},{x:48,y:4,t:'b'},
            
            // Orb section
            {x:55,y:0,t:'s'},{x:56,y:0,t:'s'},{x:57,y:0,t:'s'}, 
            {x:65,y:0,t:'b'},{x:65,y:1,t:'o'},
            {x:75,y:2,t:'b'},{x:76,y:2,t:'b'},{x:77,y:3,t:'b'},
            {x:80,y:0,t:'s'},{x:81,y:0,t:'s'},
            
            // More platforms
            {x:90,y:1,t:'b'},{x:91,y:1,t:'b'},{x:92,y:2,t:'b'},
            {x:95,y:0,t:'p'},
            {x:102,y:5,t:'b'},{x:103,y:5,t:'b'},{x:104,y:5,t:'b'},
            {x:110,y:0,t:'s'},{x:111,y:0,t:'s'},{x:112,y:0,t:'s'},
            
            // Ship section portal
            {x:125,y:0,t:'sp'},
            
            // Ship obstacles (platforms in air)
            {x:135,y:3,t:'b'},{x:136,y:3,t:'b'},{x:137,y:3,t:'b'},
            {x:135,y:6,t:'b'},{x:136,y:6,t:'b'},{x:137,y:6,t:'b'},
            {x:145,y:2,t:'b'},{x:146,y:2,t:'b'},
            {x:145,y:7,t:'b'},{x:146,y:7,t:'b'},
            {x:155,y:4,t:'b'},{x:156,y:4,t:'b'},{x:157,y:4,t:'b'},
            {x:165,y:2,t:'b'},{x:166,y:2,t:'b'},
            {x:165,y:6,t:'b'},{x:166,y:6,t:'b'},
            {x:175,y:1,t:'b'},{x:176,y:1,t:'b'},{x:177,y:1,t:'b'},
            {x:175,y:8,t:'b'},{x:176,y:8,t:'b'},{x:177,y:8,t:'b'},
            
            // Back to cube
            {x:190,y:0,t:'cp'},
            
            // Final cube section
            {x:200,y:0,t:'s'},{x:201,y:0,t:'s'},
            {x:208,y:0,t:'b'},{x:208,y:1,t:'b'},{x:209,y:2,t:'b'},
            {x:215,y:0,t:'p'},
            {x:222,y:5,t:'b'},{x:223,y:5,t:'b'},{x:224,y:5,t:'b'},
            {x:230,y:0,t:'s'},{x:231,y:0,t:'s'},{x:232,y:0,t:'s'},
            {x:240,y:1,t:'b'},{x:241,y:2,t:'b'},{x:242,y:3,t:'b'},
            {x:250,y:0,t:'o'},{x:250,y:1,t:'b'},
            {x:260,y:0,t:'s'},{x:261,y:0,t:'s'},
            
            // End portal
            {x:275,y:0,t:'e'}
        ]
    },
    {
        id: 1,
        name: "BACK ON TRACK",
        difficulty: "Normal",
        stars: 2,
        length: 300,
        color: "#8e44ad",
        data: [
            {x:10,y:0,t:'p'},{x:14,y:3,t:'b'},{x:15,y:3,t:'b'},
            {x:20,y:0,t:'s'},{x:22,y:1,t:'b'},{x:24,y:2,t:'b'},
            {x:26,y:3,t:'p'},{x:32,y:6,t:'b'},{x:32,y:7,t:'s'}
        ]
    },
    {
        id: 2,
        name: "POLARGEIST",
        difficulty: "Hard",
        stars: 3,
        length: 350,
        color: "#27ae60",
        data: [
            {x:10,y:1,t:'o'},{x:15,y:3,t:'o'},{x:20,y:5,t:'o'}
        ]
    }
];

const SKINS = [
    {id:0, cost:0, name:"Default"}, 
    {id:1, cost:50, name:"Creeper"},
    {id:2, cost:100, name:"Pilot"},
    {id:3, cost:200, name:"Demon"},
    {id:4, cost:500, name:"Companion"}
];

const COLORS = [
    {id:0, cost:0, hex:"#ffff00"}, // Yellow
    {id:1, cost:20, hex:"#00ff00"}, // Green
    {id:2, cost:20, hex:"#00ffff"}, // Cyan
    {id:3, cost:50, hex:"#ff0000"}, // Red
    {id:4, cost:50, hex:"#ff00ff"}, // Pink
    {id:5, cost:100, hex:"#ffffff"}, // White
    {id:6, cost:100, hex:"#222222"}  // Black
];

/* --- SAVE SYSTEM --- */
const SaveSys = {
    data: {
        orbs: 0,
        unlockedSkins: [0],
        unlockedColors: [0],
        currentSkin: 0,
        currentColor: 0,
        levelProgress: {} // {0: 55, 1: 100}
    },
    load() {
        const str = localStorage.getItem('gd_save');
        if(str) this.data = {...this.data, ...JSON.parse(str)};
    },
    save() {
        localStorage.setItem('gd_save', JSON.stringify(this.data));
    },
    addOrbs(amount) {
        this.data.orbs += amount;
        this.save();
    },
    unlock(type, id, cost) {
        if(this.data.orbs >= cost) {
            this.data.orbs -= cost;
            if(type === 'skin') this.data.unlockedSkins.push(id);
            else this.data.unlockedColors.push(id);
            this.save();
            return true;
        }
        return false;
    }
};

/* --- AUDIO ENGINE --- */
const AudioSys = {
    ctx: null,
    init() {
        if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if(this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone(freq, type, dur, vol=0.1) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + dur);
    },
    jump() { this.playTone(300, 'square', 0.1); },
    die() { this.playTone(100, 'sawtooth', 0.5, 0.3); },
    orb() { this.playTone(600, 'sine', 0.15, 0.2); },
    win() { this.playTone(400, 'sine', 0.2); setTimeout(()=>this.playTone(600,'sine',0.4),200); }
};

/* --- RENDERING --- */
const Renderer = {
    drawPlayer(ctx, x, y, angle, skinId, colorHex) {
        const s = 50; // Visual size
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        
        // Base
        ctx.fillStyle = colorHex;
        ctx.fillRect(-s/2, -s/2, s, s);
        
        // Border
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#000';
        ctx.strokeRect(-s/2, -s/2, s, s);
        
        // Inner Glow
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 2;
        ctx.strokeRect(-s/2+4, -s/2+4, s-8, s-8);

        // Faces
        ctx.fillStyle = '#000';
        if(skinId === 0) { // Default
            ctx.fillRect(8, -8, 10, 10); ctx.fillRect(-18, -8, 10, 10); // eyes
            ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(-10, 10); ctx.lineTo(10, 10); ctx.stroke();
        } else if (skinId === 1) { // Creeper
            ctx.fillRect(-10, -10, 5, 5); ctx.fillRect(5, -10, 5, 5);
            ctx.fillRect(-5, 0, 10, 10);
            ctx.fillRect(-10, 10, 5, 10); ctx.fillRect(5, 10, 5, 10);
        } else if (skinId === 2) { // Pilot
            ctx.fillRect(-20, -5, 40, 10); // visor
        } else if (skinId === 3) { // Demon
            ctx.beginPath(); ctx.moveTo(-15,-10); ctx.lineTo(-5,0); ctx.lineTo(-15,5); ctx.fill(); // eye
            ctx.beginPath(); ctx.moveTo(15,-10); ctx.lineTo(5,0); ctx.lineTo(15,5); ctx.fill();
            ctx.fillRect(-10, 12, 20, 3); // mouth
        } else { // Companion
            ctx.fillStyle = '#ffaaaa'; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill();
        }

        ctx.restore();
    },

    drawSpike(ctx, x, y) {
        ctx.save();
        ctx.translate(x, y);
        
        // Base shadow
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath(); 
        ctx.moveTo(2, 64); 
        ctx.lineTo(32, 2); 
        ctx.lineTo(62, 64); 
        ctx.fill();
        
        // Main gradient
        const grad = ctx.createLinearGradient(0, 64, 32, 0);
        grad.addColorStop(0, '#1a1a1a');
        grad.addColorStop(0.3, '#333');
        grad.addColorStop(0.6, '#666');
        grad.addColorStop(1, '#999');
        ctx.fillStyle = grad;
        ctx.beginPath(); 
        ctx.moveTo(0, 64); 
        ctx.lineTo(32, 0); 
        ctx.lineTo(64, 64); 
        ctx.fill();
        
        // Bright edge
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(1, 63);
        ctx.lineTo(32, 1);
        ctx.stroke();
        
        // Dark edge
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(32, 1);
        ctx.lineTo(63, 63);
        ctx.stroke();
        
        // Outline
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath(); 
        ctx.moveTo(0, 64); 
        ctx.lineTo(32, 0); 
        ctx.lineTo(64, 64);
        ctx.stroke();
        
        ctx.restore();
    },

    drawBlock(ctx, x, y) {
        // Dark base
        ctx.fillStyle = '#0a0a0a'; 
        ctx.fillRect(x, y, 64, 64);
        
        // Bright cyan border
        const borderGrad = ctx.createLinearGradient(x, y, x, y+64);
        borderGrad.addColorStop(0, '#00ffff');
        borderGrad.addColorStop(1, '#0088aa');
        ctx.strokeStyle = borderGrad;
        ctx.lineWidth = 4;
        ctx.strokeRect(x+2, y+2, 60, 60);
        
        // Inner glow
        ctx.fillStyle = 'rgba(0,255,255,0.15)';
        ctx.fillRect(x+6, y+6, 52, 52);
        
        // Corner highlights
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x+6, y+20);
        ctx.lineTo(x+6, y+6);
        ctx.lineTo(x+20, y+6);
        ctx.stroke();
    },

    drawOrb(ctx, x, y) {
        ctx.fillStyle = '#ffff00'; 
        ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(x+32, y+32, 20, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.stroke();
    },
    
    drawPad(ctx, x, y) {
        ctx.fillStyle = '#ff00ff'; 
        ctx.shadowColor = '#ff00ff'; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(x+32, y+64, 20, Math.PI, 0); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(x+10, y+64); ctx.lineTo(x+54, y+64); ctx.stroke();
    },
    
    drawShip(ctx, x, y, angle, colorHex) {
        const s = 60;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        
        // Ship body (dome top + base)
        ctx.fillStyle = colorHex;
        ctx.beginPath();
        ctx.arc(0, 0, s/2, Math.PI, 0, true); // Dome top
        ctx.lineTo(s/2, s/3);
        ctx.lineTo(-s/2, s/3);
        ctx.closePath();
        ctx.fill();
        
        // Border
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Cockpit window
        ctx.fillStyle = 'rgba(0,200,255,0.7)';
        ctx.beginPath();
        ctx.arc(0, -5, s/4, Math.PI, 0, true);
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Thruster glow
        ctx.fillStyle = '#ff8800';
        ctx.shadowColor = '#ff8800';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.ellipse(0, s/3, s/6, s/8, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.restore();
    },
    
    drawPortal(ctx, x, y, type) {
        // type: 'ship' or 'cube'
        const color = type === 'ship' ? '#ffaa00' : '#00ff00';
        
        // Portal frame
        ctx.strokeStyle = color;
        ctx.lineWidth = 6;
        ctx.shadowColor = color;
        ctx.shadowBlur = 20;
        ctx.strokeRect(x+10, y, 44, 128);
        ctx.strokeRect(x+15, y+5, 34, 118);
        ctx.shadowBlur = 0;
        
        // Icon in center
        ctx.fillStyle = color;
        ctx.font = 'bold 30px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const icon = type === 'ship' ? '‚úà' : '‚ñ†';
        ctx.fillText(icon, x+32, y+64);
    },
    
    drawEndPortal(ctx, x, y) {
        // End portal (finish line)
        const grad = ctx.createLinearGradient(x, y, x, y+128);
        grad.addColorStop(0, '#ffff00');
        grad.addColorStop(0.5, '#ff00ff');
        grad.addColorStop(1, '#00ffff');
        
        ctx.strokeStyle = grad;
        ctx.lineWidth = 8;
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 25;
        ctx.strokeRect(x+8, y, 48, 128);
        ctx.strokeRect(x+14, y+6, 36, 116);
        ctx.shadowBlur = 0;
        
        // Star burst in center
        ctx.fillStyle = '#ffffff';
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        for(let i=0; i<8; i++) {
            const angle = (i * Math.PI) / 4;
            const r = i % 2 === 0 ? 15 : 8;
            const px = x + 32 + Math.cos(angle) * r;
            const py = y + 64 + Math.sin(angle) * r;
            if(i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
    }
};

/* --- MAIN ENGINE --- */
const Game = {
    canvas: null, ctx: null,
    state: 'MENU', // MENU, LEVEL_SELECT, PLAY, SHOP, DEATH
    
    // Level
    currentLevelId: 0,
    levelData: null,
    
    // Physics
    p: { x:0, y:0, vx:0, vy:0, angle:0, grounded:false, mode:'cube' }, // mode: 'cube' or 'ship'
    camX: 0,
    floorY: 0,
    ceilingY: 0,
    
    // Logic
    activeParticles: [],
    attempt: 1,
    startObjIndex: 0,
    input: { tap: false, hold: false, buffer: 0, coyote: 0 },
    lastTime: 0,

    init() {
        SaveSys.load();
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d', {alpha:false});
        this.resize();
        window.onresize = () => this.resize();
        
        // Input Binding
        const bind = (e, val) => {
            if(this.state === 'PLAY' && e.target.tagName !== 'DIV') {
                if(val) { this.input.tap = true; this.input.hold = true; this.input.buffer = CONFIG.BUFFER_TIME; }
                else { this.input.hold = false; }
            }
        };
        window.onkeydown = e => { if(e.code==='Space'||e.code==='ArrowUp') bind(e, true); };
        window.onkeyup = e => { if(e.code==='Space'||e.code==='ArrowUp') bind(e, false); };
        window.onmousedown = e => bind(e, true);
        window.onmouseup = e => bind(e, false);
        window.ontouchstart = e => { bind(e, true); };
        window.ontouchend = e => bind(e, false);

        // UI Binding
        document.getElementById('btn-to-levels').onclick = () => this.toLevelSelect();
        document.getElementById('btn-back-menu').onclick = () => this.toMenu();
        document.getElementById('btn-garage').onclick = () => this.toGarage();
        document.getElementById('btn-back-garage').onclick = () => this.toMenu();
        document.getElementById('lvl-next').onclick = () => this.cycleLevel(1);
        document.getElementById('lvl-prev').onclick = () => this.cycleLevel(-1);
        document.getElementById('btn-start-level').onclick = () => this.startLevel();
        document.getElementById('btn-retry').onclick = () => this.startLevel();
        document.getElementById('btn-quit').onclick = () => this.toMenu();
        document.getElementById('btn-pause').onclick = () => { this.state = 'DEATH'; document.getElementById('screen-death').classList.remove('hidden'); document.getElementById('death-msg').innerText="PAUSED"; };

        // Loop
        requestAnimationFrame(t => this.loop(t));
        this.renderGarage();
    },

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.floorY = this.canvas.height - 150;
        this.ceilingY = 50; // Top boundary for ship
    },
    
    // --- STATE MANAGEMENT ---
    
    switchScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        document.getElementById('ui-layer').classList.add('hidden');
        if(id) document.getElementById(id).classList.remove('hidden');
    },

    toMenu() {
        this.state = 'MENU';
        this.switchScreen('screen-menu');
        this.resetCameraAuto();
    },

    toLevelSelect() {
        this.state = 'LEVEL_SELECT';
        this.switchScreen('screen-levels');
        this.updateLevelCard();
    },

    toGarage() {
        this.state = 'SHOP';
        this.switchScreen('screen-garage');
        this.renderGarage();
    },

    cycleLevel(dir) {
        this.currentLevelId = (this.currentLevelId + dir + LEVELS.length) % LEVELS.length;
        this.updateLevelCard();
    },

    updateLevelCard() {
        const lvl = LEVELS[this.currentLevelId];
        document.getElementById('lvl-name').innerText = lvl.name;
        document.getElementById('lvl-diff').innerText = lvl.difficulty;
        document.getElementById('lvl-stars').innerText = lvl.stars + " ‚òÖ";
        const prog = SaveSys.data.levelProgress[this.currentLevelId] || 0;
        document.getElementById('lvl-progress').innerText = `Best: ${prog}%`;
    },

    startLevel() {
        AudioSys.init();
        this.state = 'PLAY';
        this.switchScreen(null);
        document.getElementById('game-hud').classList.remove('hidden');
        
        // Load Level Data
        const raw = LEVELS[this.currentLevelId];
        // Generate floor data + object data
        this.levelData = {
            endX: raw.length * CONFIG.TILE_SIZE,
            objects: raw.data.map(o => ({
                x: o.x * CONFIG.TILE_SIZE,
                y: o.y * CONFIG.TILE_SIZE,
                t: o.t,
                w: CONFIG.TILE_SIZE, h: CONFIG.TILE_SIZE,
                hit: false
            })).sort((a,b)=>a.x-b.x)
        };
        
        // Reset Player
        this.p = { x: 0, y: 0, vx: CONFIG.SPEED, vy: 0, angle: 0, grounded: true, mode: 'cube' };
        this.input.buffer = 0;
        this.camX = 0;
        this.activeParticles = [];
        this.lastTime = performance.now();
        this.attempt = 1;
    },

    // --- LOGIC ---

    loop(now) {
        const dt = Math.min((now - this.lastTime) / 1000, 0.1);
        this.lastTime = now;

        if(this.state === 'PLAY') {
            this.updatePhysics(dt);
        } else if (this.state === 'MENU' || this.state === 'LEVEL_SELECT') {
            this.camX += 100 * dt; // Auto scroll bg
        }

        this.render();
        requestAnimationFrame(t => this.loop(t));
    },

    updatePhysics(dt) {
        const p = this.p;
        
        // Timers
        if(this.input.buffer > 0) this.input.buffer -= dt;
        if(this.input.coyote > 0) this.input.coyote -= dt;

        if(p.mode === 'cube') {
            // CUBE MODE PHYSICS
            
            // Gravity
            p.vy -= CONFIG.GRAVITY * dt;
            if(p.vy < -CONFIG.TERMINAL) p.vy = -CONFIG.TERMINAL;

            // Move
            p.x += p.vx * dt;
            p.y += p.vy * dt;

            // Floor Logic
            if(p.y <= 0) {
                p.y = 0;
                p.vy = 0;
                p.grounded = true;
                this.input.coyote = CONFIG.COYOTE_TIME;
                // Snap Angle to nearest 90 degrees
                const snap = Math.round(p.angle / (Math.PI/2)) * (Math.PI/2);
                p.angle += (snap - p.angle) * 0.2;
            } else {
                p.grounded = false;
                // Rotation for 360¬∞ per jump (~0.55s) = 2œÄ/0.55 ‚âà 11.4 rad/s
                p.angle -= CONFIG.ROTATION_SPEED * dt;
            }

            // Jump (Buffer or Tap)
            if((this.input.buffer > 0) && (p.grounded || this.input.coyote > 0)) {
                p.vy = CONFIG.JUMP_FORCE;
                p.grounded = false;
                this.input.buffer = 0;
                this.input.coyote = 0;
                AudioSys.jump();
            }
        } else if(p.mode === 'ship') {
            // SHIP MODE PHYSICS
            
            // Ship gravity and thrust
            if(this.input.hold) {
                // Flying up
                p.vy += CONFIG.SHIP_UP_FORCE * dt;
                if(p.vy > CONFIG.SHIP_TERMINAL_UP) p.vy = CONFIG.SHIP_TERMINAL_UP;
            } else {
                // Falling down
                p.vy -= CONFIG.SHIP_GRAVITY * dt;
                if(p.vy < -CONFIG.SHIP_TERMINAL_DOWN) p.vy = -CONFIG.SHIP_TERMINAL_DOWN;
            }
            
            // Move
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            
            // Ship rotation based on velocity
            const targetAngle = Math.atan2(p.vy, p.vx * 0.5) * 0.3; // Subtle tilt
            p.angle += (targetAngle - p.angle) * 0.15;
            
            // Floor and ceiling bounds
            const maxY = (this.canvas.height - this.floorY - 80);
            if(p.y <= 20) {
                p.y = 20;
                p.vy = 0;
            } else if(p.y >= maxY) {
                p.y = maxY;
                p.vy = 0;
            }
            
            p.grounded = false;
        }

        // Collisions
        this.checkCollisions();
        
        // Camera
        this.camX = p.x - 300;

        // Progress
        const pct = Math.min(100, Math.floor((p.x / this.levelData.endX) * 100));
        document.getElementById('prog-bar').style.width = pct + "%";
        document.getElementById('prog-text').innerText = pct + "%";

        if(p.x > this.levelData.endX) this.winLevel();
    },

    checkCollisions() {
        const p = this.p;
        const ts = CONFIG.TILE_SIZE;
        const hitSize = ts * CONFIG.HITBOX_SCALE; 
        const offset = (ts - hitSize)/2;
        
        const pRect = { 
            l: p.x - hitSize/2, r: p.x + hitSize/2, 
            b: p.y, t: p.y + hitSize 
        };

        const viewL = p.x - ts;
        const viewR = p.x + ts*2;

        for(let obj of this.levelData.objects) {
            if(obj.x > viewR) break; // Optimization
            if(obj.x + obj.w < viewL) continue;

            // Simple AABB
            if(pRect.r > obj.x + offset && pRect.l < obj.x + obj.w - offset &&
               pRect.t > obj.y + offset && pRect.b < obj.y + obj.h - offset) {
                
                if(obj.t === 's') {
                    // Spike: Death (only in cube mode, or if ship hits spike)
                    if(p.mode === 'cube') {
                        // Refined spike hitbox - only bottom 60% is deadly
                        if(pRect.b < obj.y + obj.h * 0.6) this.die();
                    } else {
                        this.die(); // Ship dies on any spike touch
                    }
                }
                else if(obj.t === 'b') {
                    if(p.mode === 'cube') {
                        this.resolveBlock(obj, pRect);
                    } else {
                        // Ship dies on block collision
                        this.die();
                    }
                }
                else if(obj.t === 'o' && this.input.hold && !obj.hit) {
                    // Orb (only in cube mode)
                    if(p.mode === 'cube') {
                        p.vy = CONFIG.JUMP_FORCE;
                        p.grounded = false;
                        obj.hit = true;
                        AudioSys.orb();
                    }
                }
                else if(obj.t === 'p') {
                    // Pad (only in cube mode)
                    if(p.mode === 'cube' && !obj.hit) {
                        p.vy = CONFIG.JUMP_FORCE * 1.3;
                        p.grounded = false;
                        obj.hit = true;
                        AudioSys.orb();
                    }
                }
                else if(obj.t === 'sp' && !obj.hit) {
                    // Ship portal
                    p.mode = 'ship';
                    p.y = 200; // Start at mid-height
                    p.vy = 0;
                    obj.hit = true;
                    AudioSys.orb();
                }
                else if(obj.t === 'cp' && !obj.hit) {
                    // Cube portal
                    p.mode = 'cube';
                    p.y = 0; // Land on ground
                    p.vy = 0;
                    p.grounded = true;
                    obj.hit = true;
                    AudioSys.orb();
                }
                else if(obj.t === 'e' && !obj.hit) {
                    // End portal
                    obj.hit = true;
                    this.winLevel();
                }
            }
        }
    },

    resolveBlock(obj, pRect) {
        const p = this.p;
        // Check overlap depths
        const oL = (p.x + CONFIG.TILE_SIZE/2) - obj.x;
        const oR = (obj.x + obj.w) - (p.x - CONFIG.TILE_SIZE/2);
        const oT = (obj.y + obj.h) - p.y; // Landing
        const oB = (p.y + CONFIG.TILE_SIZE) - obj.y; // Ceiling

        const minX = Math.min(oL, oR);
        const minY = Math.min(oT, oB);

        if(minY < minX) {
            // Vertical
            if(oT < oB && p.vy <= 0) { // Land on top
                p.y = obj.y + obj.h;
                p.vy = 0;
                p.grounded = true;
                this.input.coyote = CONFIG.COYOTE_TIME;
                const snap = Math.round(p.angle / (Math.PI/2)) * (Math.PI/2);
                p.angle = snap;
            } else if (p.vy > 0) { // Hit Head
                p.y = obj.y - CONFIG.TILE_SIZE;
                p.vy = 0;
            }
        } else {
            // Horizontal = Death
            if(minX > 10) this.die(); // Tolerance
        }
    },

    die() {
        if(this.state === 'DEATH') return;
        this.state = 'DEATH';
        AudioSys.die();
        this.spawnParticles(this.p.x, this.p.y, 30);
        
        this.attempt++;
        
        document.getElementById('screen-death').classList.remove('hidden');
        document.getElementById('death-msg').innerText = `CRASHED - Attempt ${this.attempt}`;
        
        // Progress Logic
        const pct = Math.floor((this.p.x / this.levelData.endX) * 100);
        document.getElementById('death-prog').style.width = pct + "%";
        
        // Save Progress & Give Orbs
        const oldBest = SaveSys.data.levelProgress[this.currentLevelId] || 0;
        if(pct > oldBest) {
            SaveSys.data.levelProgress[this.currentLevelId] = pct;
            // Give orbs for new progress (simplified: 1 orb per 1 percent gained)
            SaveSys.addOrbs(pct - oldBest); 
        }
    },

    winLevel() {
        this.state = 'DEATH'; // Reuse death screen for now
        AudioSys.win();
        document.getElementById('screen-death').classList.remove('hidden');
        document.getElementById('death-msg').innerText = "LEVEL COMPLETE!";
        document.getElementById('death-prog').style.width = "100%";
        
        const oldBest = SaveSys.data.levelProgress[this.currentLevelId] || 0;
        if(oldBest < 100) {
            SaveSys.data.levelProgress[this.currentLevelId] = 100;
            SaveSys.addOrbs((100 - oldBest) + 50); // Bonus 50 for finish
        }
    },

    spawnParticles(x, y, n) {
        const color = COLORS[SaveSys.data.currentColor].hex;
        for(let i=0; i<n; i++) {
            this.activeParticles.push({
                x:x, 
                y:y, 
                vx:(Math.random()-0.5)*800, 
                vy:Math.random()*600, 
                life:1.0,
                color: color,
                size: 4 + Math.random()*6
            });
        }
    },

    resetCameraAuto() { this.camX = 0; },

    // --- GARAGE RENDERER ---
    renderGarage() {
        document.getElementById('orb-display').innerText = SaveSys.data.orbs;
        
        // Skins
        const iconGrid = document.getElementById('icon-grid');
        iconGrid.innerHTML = '';
        SKINS.forEach(skin => {
            const d = document.createElement('div');
            d.className = 'shop-item';
            const unlocked = SaveSys.data.unlockedSkins.includes(skin.id);
            if(!unlocked) d.classList.add('locked');
            if(SaveSys.data.currentSkin === skin.id) d.classList.add('selected');
            
            // Canvas preview
            const cvs = document.createElement('canvas');
            cvs.width = 60; cvs.height = 60;
            const ctx = cvs.getContext('2d');
            Renderer.drawPlayer(ctx, 30, 30, 0, skin.id, COLORS[SaveSys.data.currentColor].hex);
            d.appendChild(cvs);

            // Cost overlay
            if(!unlocked) {
                const tag = document.createElement('div');
                tag.style = "position:absolute; bottom:0; right:0; background:black; color:#0ff; font-size:10px; padding:2px;";
                tag.innerText = skin.cost;
                d.appendChild(tag);
            }

            d.onclick = () => {
                if(unlocked) { SaveSys.data.currentSkin = skin.id; SaveSys.save(); this.renderGarage(); }
                else if(SaveSys.unlock('skin', skin.id, skin.cost)) { this.renderGarage(); }
                else alert("Not enough Orbs!");
            };
            iconGrid.appendChild(d);
        });

        // Colors
        const colGrid = document.getElementById('color-grid');
        colGrid.innerHTML = '';
        COLORS.forEach(col => {
            const d = document.createElement('div');
            d.className = 'shop-item';
            d.style.backgroundColor = col.hex;
            const unlocked = SaveSys.data.unlockedColors.includes(col.id);
            if(!unlocked) { 
                d.classList.add('locked');
                d.innerText = col.cost;
                d.style.display='flex'; d.style.alignItems='center'; d.style.justifyContent='center'; d.style.color='#000'; d.style.fontWeight='bold';
            }
            if(SaveSys.data.currentColor === col.id) d.style.border = "3px solid white";
            
            d.onclick = () => {
                if(unlocked) { SaveSys.data.currentColor = col.id; SaveSys.save(); this.renderGarage(); }
                else if(SaveSys.unlock('color', col.id, col.cost)) { this.renderGarage(); }
            };
            colGrid.appendChild(d);
        });
    },

    // --- MAIN RENDERER ---
    render() {
        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;
        
        // Background - Multi-layer gradient
        const levelCol = this.state === 'PLAY' ? LEVELS[this.currentLevelId].color : '#2980b9';
        const grad = ctx.createLinearGradient(0,0,0,h);
        grad.addColorStop(0, levelCol); 
        grad.addColorStop(0.6, '#001a33');
        grad.addColorStop(1, '#000');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,w,h);

        // Grid / Ground
        ctx.save();
        const groundY = this.floorY;
        const cam = this.camX;
        
        // Parallax BG layers
        ctx.globalAlpha = 0.08;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        
        // Layer 1 - Slow
        const off1 = -(cam * 0.1) % 150;
        ctx.beginPath();
        for(let i=off1; i<w; i+=150) { ctx.moveTo(i,0); ctx.lineTo(i,h); }
        for(let i=0; i<h; i+=150) { ctx.moveTo(0,i); ctx.lineTo(w,i); }
        ctx.stroke();
        
        // Layer 2 - Medium
        ctx.globalAlpha = 0.05;
        const off2 = -(cam * 0.3) % 100;
        ctx.beginPath();
        for(let i=off2; i<w; i+=100) { ctx.moveTo(i,0); ctx.lineTo(i,h); }
        ctx.stroke();
        
        ctx.globalAlpha = 1.0;

        // Floor
        const groundPatternOff = -(cam) % CONFIG.TILE_SIZE;
        ctx.fillStyle = '#000'; 
        ctx.fillRect(0, groundY, w, h-groundY);
        
        // Floor line with glow
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 8;
        ctx.strokeStyle = '#00ffff'; 
        ctx.lineWidth = 3;
        ctx.beginPath(); 
        ctx.moveTo(0, groundY); 
        ctx.lineTo(w, groundY); 
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Floor grid details
        ctx.globalAlpha = 0.2;
        ctx.strokeStyle = '#0088aa';
        ctx.lineWidth = 1;
        for(let i=groundPatternOff; i<w; i+=CONFIG.TILE_SIZE) {
            ctx.strokeRect(i, groundY, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
        }
        ctx.globalAlpha = 1.0;

        if(this.state === 'PLAY' || this.state === 'DEATH') {
            // Draw Level Objects
            const startX = cam - 100;
            const endX = cam + w + 100;
            
            for(let obj of this.levelData.objects) {
                if(obj.x < startX || obj.x > endX) continue;
                const scrX = obj.x - cam;
                const scrY = groundY - obj.y - obj.h;
                
                if(obj.t === 's') Renderer.drawSpike(ctx, scrX, scrY);
                else if(obj.t === 'b') Renderer.drawBlock(ctx, scrX, scrY);
                else if(obj.t === 'o') Renderer.drawOrb(ctx, scrX, scrY);
                else if(obj.t === 'p') Renderer.drawPad(ctx, scrX, scrY);
                else if(obj.t === 'sp') Renderer.drawPortal(ctx, scrX, groundY - 128, 'ship');
                else if(obj.t === 'cp') Renderer.drawPortal(ctx, scrX, groundY - 128, 'cube');
                else if(obj.t === 'e') Renderer.drawEndPortal(ctx, scrX, groundY - 128);
            }

            // Draw Particles
            for(let i=this.activeParticles.length-1; i>=0; i--) {
                let part = this.activeParticles[i];
                part.x += part.vx * 0.016; 
                part.y += part.vy * 0.016; 
                part.vy -= 1500 * 0.016; // Gravity on particles
                part.life -= 0.015;
                if(part.life <= 0) { this.activeParticles.splice(i,1); continue; }
                
                ctx.fillStyle = part.color.replace(')', `,${part.life})`).replace('rgb', 'rgba').replace('#', 'rgba(');
                // Parse hex color
                if(part.color.startsWith('#')) {
                    const r = parseInt(part.color.slice(1,3), 16);
                    const g = parseInt(part.color.slice(3,5), 16);
                    const b = parseInt(part.color.slice(5,7), 16);
                    ctx.fillStyle = `rgba(${r},${g},${b},${part.life})`;
                }
                ctx.fillRect(part.x - cam, groundY - part.y, part.size, part.size);
            }

            // Draw Player
            if(this.state !== 'DEATH') {
                const scrX = this.p.x - cam;
                const scrY = groundY - this.p.y - 32; // Center
                
                if(this.p.mode === 'cube') {
                    Renderer.drawPlayer(ctx, scrX, scrY, -this.p.angle, SaveSys.data.currentSkin, COLORS[SaveSys.data.currentColor].hex);
                } else if(this.p.mode === 'ship') {
                    Renderer.drawShip(ctx, scrX, scrY, -this.p.angle, COLORS[SaveSys.data.currentColor].hex);
                }
            }
        }
        
        ctx.restore();
    }
};

window.onload = () => Game.init();
</script>
</body>
</html>
